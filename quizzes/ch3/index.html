<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>試卷 — Regression（MSE／線性）＋布林函數｜自檢</title>
<style>
  :root{--bg:#0b0f14;--card:#121922;--ink:#e8eef7;--muted:#9fb3c8;--brand:#71b7ff;--ok:#44d07b;--bad:#ff6b6b}
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans TC","PingFang TC","Microsoft JhengHei",sans-serif;background:var(--bg);color:var(--ink);line-height:1.6}
  .wrap{max-width:1100px;margin:28px auto;padding:0 16px}
  header{display:flex;gap:10px;align-items:center;justify-content:space-between}
  h1{margin:0;font-size:clamp(20px,3vw,26px)}
  .btn{appearance:none;border:none;border-radius:10px;padding:8px 12px;background:#1f2a3a;color:var(--ink);cursor:pointer}
  .btn.primary{background:var(--brand);color:#041424;font-weight:700}
  .card{background:var(--card);border-radius:16px;padding:18px;margin:16px 0;box-shadow:0 6px 24px rgba(0,0,0,.25)}
  h2{margin:0 0 8px 0;font-size:20px}
  .q{display:grid;grid-template-columns:1.3fr 1fr;gap:14px;margin:14px 0;padding:12px;border:1px solid #223044;border-radius:12px}
  canvas{width:100%;height:320px;background:#0e141d;border-radius:10px;border:1px solid #223044}
  .opts{display:grid;gap:8px}
  .opts label{display:flex;gap:8px;align-items:flex-start;padding:8px 10px;border:1px solid #2a3547;border-radius:10px;cursor:pointer}
  .pill{display:inline-flex;align-items:center;gap:6px;border-radius:999px;padding:4px 10px;font-size:12px;background:#162232;color:var(--muted);border:1px solid #263246}
  .result{white-space:pre-wrap;background:#0e141d;border:1px solid #223044;border-radius:12px;padding:12px}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .status{display:flex;gap:8px;flex-wrap:wrap}
  .badge{padding:4px 8px;border-radius:999px;font-size:12px;border:1px solid #263246;background:#162232;color:#9fb3c8}
  .badge.ok{background:#153b2c;border-color:#2b8a57;color:#aef1c2}
  .badge.err{background:#3b1b1b;border-color:#b54646;color:#ffc9c9}
  .txt{width:100%;padding:10px;border-radius:10px;border:1px solid #2a3547;background:#0e141d;color:var(--ink)}
  @media (max-width: 820px){ .q{grid-template-columns:1fr} }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>試卷 — Regression（MSE／線性）＋布林函數</h1>
  </header>

  <section class="card">
    <div class="status">
      <span class="badge" id="chk-canvas">Canvas 渲染：待檢測</span>
    </div>
    <div class="row" style="margin-top:10px">
      <button class="btn" id="btnRefresh">重新渲染／重新檢測</button>
      <button class="btn" id="btnReset">全部清空作答</button>
    </div>
    <p class="pill" style="margin-top:10px">本卷包含 Regression 3 題（單選）＋布林函數 2 題（填數字）。完全離線可跑。</p>
  </section>

  <!-- Part R: Regression -->
  <section class="card" id="partR">
    <h2>Part R — Regression（單選）</h2>

    <div class="q" data-id="R.Q1">
      <canvas></canvas>
      <div>
        <strong>R1. 本章回歸使用的損失函數是？</strong>
        <div class="opts">
          <label><input type="radio" name="R.Q1" value="A">A. Mean Squared Error（MSE）</label>
          <label><input type="radio" name="R.Q1" value="B">B. Mean Absolute Error（MAE）</label>
          <label><input type="radio" name="R.Q1" value="C">C. Huber Loss</label>
          <label><input type="radio" name="R.Q1" value="D">D. Cross-Entropy</label>
        </div>
        <p class="pill">公式：E(g|X)= (1/N) Σ [rᵗ − g(xᵗ)]²（平方放大大誤差）</p>
      </div>
    </div>

    <div class="q" data-id="R.Q2">
      <canvas></canvas>
      <div>
        <strong>R2. 下列何者為「線性回歸模型」？</strong>
        <div class="opts">
          <label><input type="radio" name="R.Q2" value="A">A. g(x)=w₁x+w₀</label>
          <label><input type="radio" name="R.Q2" value="B">B. g(x)=w₂x²+w₁x+w₀</label>
          <label><input type="radio" name="R.Q2" value="C">C. g(x)=sin(x)</label>
          <label><input type="radio" name="R.Q2" value="D">D. g(x)=log(x)</label>
        </div>
        <p class="pill">線性回歸＝對參數線性的一次模型</p>
      </div>
    </div>

    <div class="q" data-id="R.Q3">
      <canvas></canvas>
      <div>
        <strong>R3. 同一批資料：直線、二次曲線、與高度起伏的高次曲線。哪個敘述最合理？</strong>
        <div class="opts">
          <label><input type="radio" name="R.Q3" value="A">A. 直線無法準確擬合所有資料</label>
          <label><input type="radio" name="R.Q3" value="B">B. 二次曲線通常比直線更貼近趨勢</label>
          <label><input type="radio" name="R.Q3" value="C">C. 過度複雜的模型雖貼資料但可能過擬合</label>
          <label><input type="radio" name="R.Q3" value="D">D. 以上皆是</label>
        </div>
      </div>
    </div>

    <div class="row"><button class="btn primary" data-grade="R">批改 Part R</button><span class="pill" id="scoreR">尚未作答</span></div>
    <div class="result" id="outR"></div>
  </section>

  <!-- Part B: Boolean -->
  <section class="card" id="partB">
    <h2>Part B — 布林函數計數（填空）</h2>

    <div class="q" data-id="B.Q1" style="grid-template-columns:1fr 1fr;">
      <canvas></canvas>
      <div>
        <strong>B1. 輸入 (x₁,x₂) 僅 4 種輸入情境。共有幾個不同的布林函數？（填數字）</strong>
        <input class="txt" type="text" name="B.Q1" placeholder="例如：1">
        <p class="pill">每情境輸出可 0/1 → 函數個數 = 2^(情境數)</p>
      </div>
    </div>

    <div class="q" data-id="B.Q2" style="grid-template-columns:1fr 1fr;">
      <canvas></canvas>
      <div>
        <strong>B2. 只知 (x₁,x₂)=(0,0) 的輸出為 1，其他三情境未知。可能的布林函數有幾個？（填數字）</strong>
        <input class="txt" type="text" name="B.Q2" placeholder="例如：1">
        <p class="pill">其餘 3 格可 0/1 任選 </p>
      </div>
    </div>

    <div class="row"><button class="btn primary" data-grade="B">批改 Part B</button><span class="pill" id="scoreB">尚未作答</span></div>
    <div class="result" id="outB"></div>
  </section>
</div>

<script>
/* ===== 小工具 ===== */
const $=(s,r=document)=>r.querySelector(s);
const $$=(s,r=document)=>Array.from(r.querySelectorAll(s));
const storeKey='quiz-reg-bool-v2';
const DPR = Math.max(1, window.devicePixelRatio || 1);

function scaler(min,max,pxMin,pxMax,flip=false){
  return v=>{ const t=(v-min)/((max-min)||1); const px=pxMin+t*(pxMax-pxMin); return flip?(pxMax-(px-pxMin)):px; };
}
function randn(mu=0,s=1){ let u=0,v=0; while(!u)u=Math.random(); while(!v)v=Math.random(); return mu+s*Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); }

function drawAxes(ctx,W,H,pad,xlabel,ylabel,minX,maxX,minY,maxY){
  ctx.fillStyle='#0e141d'; ctx.fillRect(0,0,W,H);
  ctx.strokeStyle='#223044'; ctx.setLineDash([4,4]);
  for(let i=0;i<=4;i++){const x=pad+i*(W-2*pad)/4; ctx.beginPath(); ctx.moveTo(x,pad); ctx.lineTo(x,H-pad); ctx.stroke();}
  for(let i=0;i<=4;i++){const y=pad+i*(H-2*pad)/4; ctx.beginPath(); ctx.moveTo(pad,y); ctx.lineTo(W-pad,y); ctx.stroke();}
  ctx.setLineDash([]);
  ctx.strokeStyle='#41536b'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(pad,H-pad); ctx.lineTo(W-pad,H-pad); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(pad,H-pad); ctx.lineTo(pad,pad); ctx.stroke();
  ctx.fillStyle='#9fb3c8'; ctx.fillText(xlabel,W/2-20,H-8);
  ctx.save(); ctx.translate(12,H/2); ctx.rotate(-Math.PI/2); ctx.fillText(ylabel,0,0); ctx.restore();
}

/* ===== Regression 圖 ===== */
function prepCanvas(canvas){
  const cssW = Math.max(1, canvas.clientWidth || 600);
  const cssH = Math.max(1, canvas.clientHeight || 320);
  const pxW = Math.round(cssW * DPR), pxH = Math.round(cssH * DPR);
  if (canvas.width !== pxW || canvas.height !== pxH){ canvas.width = pxW; canvas.height = pxH; }
  const ctx = canvas.getContext('2d');
  ctx.setTransform(DPR,0,0,DPR,0,0); // 將座標系縮放回 CSS 單位
  return {ctx, W: cssW, H: cssH, pad: 32};
}

function drawRegressionWithResiduals(canvas){
  const {ctx,W,H,pad}=prepCanvas(canvas);
  const xs=[...Array(36)].map((_,i)=>i/9), pts=xs.map(x=>[x, 2.0*x+1.0 + randn(0,0.35)]);
  const minX=Math.min(...xs), maxX=Math.max(...xs), ys=pts.map(p=>p[1]), minY=Math.min(...ys), maxY=Math.max(...ys);
  const x2px=scaler(minX,maxX,pad,W-pad,false), y2px=scaler(minY,maxY,pad,H-pad,true);
  drawAxes(ctx,W,H,pad,'x','y',minX,maxX,minY,maxY);
  const w=2.0, b=1.0;
  ctx.fillStyle='#71b7ff'; pts.forEach(([x,y])=>{ctx.beginPath(); ctx.arc(x2px(x),y2px(y),4,0,Math.PI*2); ctx.fill();});
  ctx.strokeStyle='#e8eef7'; ctx.lineWidth=2.5; ctx.beginPath(); ctx.moveTo(x2px(minX),y2px(w*minX+b)); ctx.lineTo(x2px(maxX),y2px(w*maxX+b)); ctx.stroke();
  ctx.fillStyle='#9fb3c8'; ctx.fillText(`y = ${w.toFixed(2)}x + ${b.toFixed(2)}`,(pad+6), (pad+14));
  ctx.setLineDash([6,4]); ctx.strokeStyle='#9fb3c8';
  pts.filter((_,i)=>i%6===0).forEach(([x,y])=>{const yp=w*x+b; ctx.beginPath(); ctx.moveTo(x2px(x),y2px(y)); ctx.lineTo(x2px(x),y2px(yp)); ctx.stroke();});
  ctx.setLineDash([]);
}
function drawModelForms(canvas){
  const {ctx,W,H,pad}=prepCanvas(canvas);
  drawAxes(ctx,W,H,pad,'x','g(x)',-2,2,-2,3);
  ctx.fillStyle='#9fb3c8';
  ctx.fillText('候選模型：', pad+6, pad+16);
  ctx.fillText('A: g(x)=w₁x+w₀（線性；參數一次）', pad+6, pad+36);
  ctx.fillText('B: g(x)=w₂x²+w₁x+w₀（非線性形狀）', pad+6, pad+56);
  ctx.fillText('C: g(x)=sin x', pad+6, pad+76);
  ctx.fillText('D: g(x)=log x', pad+6, pad+96);
}
function drawThreeFits(canvas){
  const {ctx,W,H,pad}=prepCanvas(canvas);
  const xs=[...Array(45)].map((_,i)=>i/10), pts=xs.map(x=>[x, 0.4*x*x + 0.6*x + 1 + randn(0,0.15)]);
  const minX=Math.min(...xs), maxX=Math.max(...xs), ys=pts.map(p=>p[1]), minY=Math.min(...ys), maxY=Math.max(...ys);
  const x2px=scaler(minX,maxX,pad,W-pad,false), y2px=scaler(minY,maxY,pad,H-pad,true);
  drawAxes(ctx,W,H,pad,'x','y',minX,maxX,minY,maxY);
  ctx.fillStyle='#71b7ff'; pts.forEach(([x,y])=>{ctx.beginPath(); ctx.arc(x2px(x),y2px(y),3.5,0,Math.PI*2); ctx.fill();});
  const L=x=>0.7*x+1.2; ctx.strokeStyle='#e8eef7'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(x2px(minX),y2px(L(minX))); ctx.lineTo(x2px(maxX),y2px(L(maxX))); ctx.stroke();
  const Q=x=>0.4*x*x+0.6*x+1.0; ctx.strokeStyle='#66e6d4'; ctx.lineWidth=2; ctx.beginPath(); for(let x=minX;x<=maxX;x+=0.02){const y=Q(x); const px=x2px(x), py=y2px(y); if(x===minX) ctx.moveTo(px,py); else ctx.lineTo(px,py);} ctx.stroke();
  const Hh=x=>Q(x)+0.2*Math.sin(10*x); ctx.strokeStyle='#ffb86b'; ctx.lineWidth=1.5; ctx.beginPath(); for(let x=minX;x<=maxX;x+=0.01){const y=Hh(x); const px=x2px(x), py=y2px(y); if(x===minX) ctx.moveTo(px,py); else ctx.lineTo(px,py);} ctx.stroke();
  ctx.fillStyle='#9fb3c8'; ctx.fillText('白:直線  青:二次  橙:高次（易過擬合）', pad+6, pad+14);
}

/* ===== Boolean 示意表 ===== */
function drawTruthTableSketch(canvas, markFixed=false){
  const {ctx}=prepCanvas(canvas);
  const W = canvas.clientWidth || 600, H = canvas.clientHeight || 320;
  ctx.fillStyle='#0e141d'; ctx.fillRect(0,0,W,H);
  const left=40, top=48, rowH=36, colW=[80,80,140];
  ctx.fillStyle='#9fb3c8'; ctx.fillText('x₁', left+10, top-14); ctx.fillText('x₂', left+colW[0]+10, top-14); ctx.fillText('輸出', left+colW[0]+colW[1]+10, top-14);
  const rows=[[0,0],[0,1],[1,0],[1,1]];
  rows.forEach((r,i)=>{
    const y=top+i*rowH;
    ctx.strokeStyle='#223044'; ctx.strokeRect(left, y-24, colW[0], rowH);
    ctx.strokeRect(left+colW[0], y-24, colW[1], rowH);
    ctx.strokeRect(left+colW[0]+colW[1], y-24, colW[2], rowH);
    ctx.fillStyle='#e8eef7'; ctx.fillText(String(r[0]), left+colW[0]-26, y); ctx.fillText(String(r[1]), left+colW[0]+colW[1]-26, y);
    if(markFixed && i===0){ ctx.fillStyle='#71b7ff'; ctx.fillText('1（已知）', left+colW[0]+colW[1]+22, y); }
  });
}

/* ===== 渲染檢測（修正：不再在檢測時清空畫布） ===== */
function setCanvasBadge(state,msg){
  const el=$('#chk-canvas'); if(!el) return;
  el.className='badge'; // reset
  if(state==='pending'){ el.textContent='⏳ 檢測中…'; }
  else if(state==='ok'){ el.classList.add('ok'); el.textContent='✅ '+(msg||'Canvas 渲染 OK'); }
  else { el.classList.add('err'); el.textContent='❌ '+(msg||'Canvas 未成功渲染'); }
}
function canvasHasPixels(c){
  try{
    const w=c.width, h=c.height; if(!w||!h) return false;
    const ctx=c.getContext('2d');
    const data=ctx.getImageData(0,0,Math.min(16,w),Math.min(16,h)).data; // 取左上 16x16 取樣
    for(let i=0;i<data.length;i+=4){ if(data[i]||data[i+1]||data[i+2]||data[i+3]) return true; }
    return false;
  }catch(e){ return false; }
}
function checkCanvasOnce(){
  const canv=$$('canvas'); if(!canv.length) return false;
  return canv.every(canvasHasPixels);
}
async function checkCanvasPoll(retries=6, interval=350){
  setCanvasBadge('pending');
  for(let i=0;i<retries;i++){
    await new Promise(r=>setTimeout(r, interval));
    if(checkCanvasOnce()){ setCanvasBadge('ok'); return true; }
  }
  setCanvasBadge('err','超時：未成功渲染'); return false;
}

/* ===== 初始化繪圖與行為 ===== */
function renderAll(){
  const QR=$$('#partR .q'); if(QR[0]) drawRegressionWithResiduals(QR[0].querySelector('canvas'));
  if(QR[1]) drawModelForms(QR[1].querySelector('canvas'));
  if(QR[2]) drawThreeFits(QR[2].querySelector('canvas'));
  const QB=$$('#partB .q'); if(QB[0]) drawTruthTableSketch(QB[0].querySelector('canvas'), false);
  if(QB[1]) drawTruthTableSketch(QB[1].querySelector('canvas'), true);
}

function saveState(){
  const data={};
  $$('input[type=radio]:checked').forEach(r=>data[r.name]=r.value);
  $$('input.txt').forEach(t=>data[t.name]=t.value);
  try{ localStorage.setItem(storeKey, JSON.stringify(data)); }catch(e){}
}
function loadState(){
  try{
    const data=JSON.parse(localStorage.getItem(storeKey)||'{}');
    Object.entries(data).forEach(([k,v])=>{
      const r=document.querySelector(`input[name="${k}"][value="${v}"]`); if(r) r.checked=true;
      const t=document.querySelector(`input[type="text"][name="${k}"]`); if(t) t.value=v;
    });
  }catch(e){}
}
function resetState(){ try{ localStorage.removeItem(storeKey); }catch(e){} location.reload(); }

/* ===== 批改 ===== */
function gradeR(){
  const key={'R.Q1':'A','R.Q2':'A','R.Q3':'D'};
  const exp={
    'R.Q1':'MSE：E(g|X)=(1/N)∑[r^t−g(x^t)]²；平方懲罰大誤差。',
    'R.Q2':'線性回歸指對參數線性的一次模型：g(x)=w₁x+w₀。',
    'R.Q3':'複雜度↑先降訓練誤差，但過高會過擬合；二次常比一次貼趨勢。'
  };
  let correct=0,total=3, lines=[];
  Object.entries(key).forEach(([q,ans])=>{
    const chosen=document.querySelector(`input[name="${q}"]:checked`);
    if(!chosen){ lines.push(`${q}: ⚠️ 未作答`); return; }
    const ok=chosen.value===ans; if(ok) correct++;
    lines.push(`${q}: ${ok?'✅ 正確':'❌ 錯誤（你的答案: '+chosen.value+'；正解: '+ans+'）'}`);
    lines.push('解析：'+exp[q]);
  });
  $('#scoreR').textContent=`總分：${correct} / ${total}`;
  $('#outR').textContent=lines.join('\n');
}
function normalizeNum(s){
  const t=(s||'').toString().trim().replace(/[，,\s]/g,' ');
  // 上面為相容舊資料的替代，接著真正移除空白與逗號：
  const u=t.replace(/[，,\s]+/g,'').replace(/[０-９]/g,ch=>String.fromCharCode(ch.charCodeAt(0)-0xFF10+48));
  if(u==='十六') return '16'; if(u==='八') return '8';
  return u;
}
function gradeB(){
  const ans={'B.Q1':['16'],'B.Q2':['8']};
  const exp={'B.Q1':'2^4=16（四個輸入情境，各自 0/1）','B.Q2':'2^3=8（其餘三格自由 0/1）'};
  let correct=0,total=2, lines=[];
  Object.entries(ans).forEach(([q,arr])=>{
    const v=normalizeNum(($(`input[name="${q}"]`)||{}).value);
    if(!v){ lines.push(`${q}: ⚠️ 未作答`); return; }
    const ok=arr.includes(v); if(ok) correct++;
    lines.push(`${q}: ${ok?'✅ 正確':'❌ 錯誤（你的答案: '+v+'；正解: '+arr[0]+'）'}`);
    lines.push('解析：'+exp[q]);
  });
  $('#scoreB').textContent=`總分：${correct} / ${total}`;
  $('#outB').textContent=lines.join('\n');
}

/* ===== 事件繫結 ===== */
(function boot(){
  // 等待下一個 frame，確保 layout 完成再繪製
  requestAnimationFrame(()=>{
    renderAll();
    checkCanvasPoll();
    loadState();
  });
  addEventListener('change', saveState, {passive:true});
  addEventListener('input', saveState, {passive:true});
  const btnR=$('button[data-grade="R"]'); if(btnR) btnR.addEventListener('click', gradeR);
  const btnB=$('button[data-grade="B"]'); if(btnB) btnB.addEventListener('click', gradeB);
  const btnRefresh=$('#btnRefresh'); if(btnRefresh) btnRefresh.addEventListener('click', ()=>{ renderAll(); checkCanvasPoll(); });
  const btnReset=$('#btnReset'); if(btnReset) btnReset.addEventListener('click', resetState);
  // 視窗尺寸改變時自動重繪
  let _rszTimer=null; addEventListener('resize', ()=>{ clearTimeout(_rszTimer); _rszTimer=setTimeout(()=>{ renderAll(); checkCanvasPoll(); }, 150); });
})();
</script>
</body>
</html>
